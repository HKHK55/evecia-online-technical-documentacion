// app.js — fixed bootstrap + robust interaction matrix
window.__APP_OK = 1;
(function(){
  // UI refs (define first so code always runs)
  var st = document.getElementById('st');
  var memo = document.getElementById('memo');
  var collapseBtn = document.getElementById('collapse-btn');
  var topPanelWrap = document.getElementById('top-panel-wrap');
  // ZAKTUALIZOWANY STATE
  var state = { 
    rows: [],
    sortKey: 'alliance', // Domyślne sortowanie
    sortDir: 'asc',
    // Nowy stan do przechowywania, czy panel jest zwinięty
    isTopPanelCollapsed: false
  };
  var graph = null;
  var busy = false;

  // Boot marker (non-fatal if #boot missing)
  try {
    var boot = document.getElementById('boot');
    if (boot) { boot.textContent = 'JS loaded'; boot.style.color = '#090'; }
  } catch(_e){}

  function debug(msg){
    var pre = document.getElementById('dbg');
    if(!pre) return;
    try { pre.textContent += (typeof msg==='string'? msg : JSON.stringify(msg)) + "\n"; }
    catch(e){ pre.textContent += String(msg) + "\n"; }
  }
  
  // *** NOWA FUNKCJA DO POZIOMEGO ZWIJANIA ***
  window.__toggleTop = function(){
      state.isTopPanelCollapsed = !state.isTopPanelCollapsed;
      if (topPanelWrap) {
          if (state.isTopPanelCollapsed) {
              topPanelWrap.classList.add('collapsed');
              if (collapseBtn) collapseBtn.textContent = '▶'; // ZMIANA: Trójkąt w prawo (sygnalizuje rozwijanie)
          } else {
              topPanelWrap.classList.remove('collapsed');
              if (collapseBtn) collapseBtn.textContent = '◀'; // ZMIANA: Trójkąt w lewo (sygnalizuje zwijanie)
          }
      }
  }

  // ---- helpers ----
  function setStatus(s){ if(st) st.textContent = s; }
  function escapeHtml(s){
    return (s||'').replace(/[&<>"']/g, function(c){
      return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c];
    });
  }
  function logo(kind,id,size){
    if(!id) return '';
    var path=(kind==='corp'?'corporations':'alliances');
    var sz=size||64;
    var url='https://images.evetech.net/'+path+'/'+id+'/logo?size='+sz;
    return '<img class="logo" src="'+url+'" alt="" loading="lazy" onerror="this.style.display=\'none\'">';
  }

  // *** NOWA, POPRAWIONA FUNKCJA ANALYZE TIMEZONE ***
  /**
   * Analizuje obiekt 'labels' ze statystyk zKB w poszukiwaniu kluczy 'tz:...'
   * i zwraca ten z największą wartością 'shipsDestroyed' lub 'kills'.
   */
  function analyzeTimezone(statsData) {
    // *** POPRAWKA: Szukamy w 'statsData.labels' ***
    var labels = (statsData && statsData.labels) ? statsData.labels : null;
    
    if (!labels) return '';
    
    var tzKills = [];
    var totalKills = 0;

    // Iterujemy po wszystkich kluczach w obiekcie 'labels'
    for (var key in labels) {
      if (labels.hasOwnProperty(key) && key.startsWith('tz:')) {
        var tzName = key.substring(3).toUpperCase(); // Pobierz 'AU', 'EU', 'US', 'RU' itd.
        // Używamy 'shipsDestroyed' LUB 'kills', w zależności od tego, co jest dostępne
        var kills = labels[key].shipsDestroyed || labels[key].kills || 0; 
        
        if (kills > 0) {
          tzKills.push({ name: tzName, kills: kills });
          totalKills += kills;
        }
      }
    }

    if (tzKills.length === 0) return '';

    // Sortuj strefy wg killi malejąco
    tzKills.sort(function(a, b) {
      return b.kills - a.kills;
    });

    var topZone = tzKills[0];
    if (topZone.kills === 0) return '';

    // Filtruj te, które są "znaczące"
    // "Znaczący" = ma co najmniej 30% killi strefy z top 1
    var significantTz = tzKills.filter(function(tz) {
      return tz.kills > 0 && (tz.kills >= topZone.kills * 0.3);
    });

    // Zwróć połączone stringi
    return significantTz.map(function(tz) { return tz.name; }).join('/');
  }
  // *** KONIEC NOWEJ FUNKCJI ***


  // ---- XHR ----
  function xhr(method,url,body,headers,cb){
    try{
      var x=new XMLHttpRequest();
      x.open(method,url,true);
      if(headers){ for(var k in headers){ try{x.setRequestHeader(k,headers[k]);}catch(e){} } }
      x.onreadystatechange=function(){ if(x.readyState===4){ cb(null,x); } };
      x.onerror=function(){ cb(new Error('XHR error')); };
      x.send(body||null);
    }catch(e){ cb(e); }
  }
  function api(action,data,cb){
    var url=(location.href.split('#')[0].split('?')[0])+'?action='+encodeURIComponent(action);
    var body=(typeof data==='string')? data : JSON.stringify(data||{});
    var headers={'Content-Type': (typeof data==='string'?'text/plain;charset=UTF-8':'application/json')};
    xhr('POST',url,body,headers,function(err,x){
      if(err) return cb(err);
      if(x.status<200||x.status>=300) return cb(new Error('HTTP '+x.status));
      try{ cb(null, JSON.parse(x.responseText)); }catch(e){ cb(e); }
    });
  }
  function esiGet(path,cb){
    xhr('GET','https://esi.evetech.net/latest/'+path,null,{'Accept':'application/json'},function(err,x){
      if(err) return cb(err);
      if(x.status<200||x.status>=300) return cb(new Error('ESI '+x.status));
      try{ cb(null, JSON.parse(x.responseText)); }catch(e){ cb(e); }
    });
  }

  // ---- utils ----
  function dedupe(list){
    var seen={}, out=[];
    for(var i=0;i<list.length;i++){ var s=list[i]; if(s && !seen[s]){ seen[s]=1; out.push(s); } }
    return out;
  }
  function resolveNamesClient(names,cb){
    var map={}, i=0;
    function step(){
      if(i>=names.length) return cb(null,map);
      var n=names[i++];
      (function tryStrict(strict){
        esiGet('search/?categories=character&search='+encodeURIComponent(n)+'&strict='+(strict?'true':'false'), function(err,j){
          var id=!err && j && j.character && j.character[0];
          if(id){ map[n.toLowerCase()]=id; step(); }
          else if(strict){ tryStrict(false); }
          else { step(); }
        });
      })(true);
    }
    step();
  }
  function loadPilotClient(id,cb){
    esiGet('characters/'+id+'/', function(err,ch){
      if(err||!ch) return cb(err||new Error('no ch'));
      var corpId=ch.corporation_id||0, corpName='', alliId=ch.alliance_id||0, alliName='';
      function finish(){
        cb(null,{ id:Number(id), name:ch.name||String(id), birthday:ch.birthday||'', corp_id:corpId, corp_name:corpName, alliance_id:alliId, alliance_name:alliName });
      }
      if(corpId){
        esiGet('corporations/'+corpId+'/', function(err2,corp){
          if(!err2&&corp){
            corpName=corp.name||'';
            if(!alliId && corp.alliance_id) alliId=corp.alliance_id;
          }
          if(alliId){
            esiGet('alliances/'+alliId+'/', function(e3,al){ if(!e3&&al) alliName=al.name||''; finish(); });
          } else finish();
        });
      } else {
        if(alliId){ esiGet('alliances/'+alliId+'/', function(e3,al){ if(!e3&&al) alliName=al.name||''; finish(); }); }
        else finish();
      }
    });
  }

  // ---- Top cache ----
  var topCache={};
  function ensureTopFor(id,cb){
    if(topCache[id]) return cb(null, topCache[id]);
    api('top',{id:id}, function(err,res){
      var t=(res&&res.top)?res.top:{ships:[],systems:[],alliances:[]};
      topCache[id]=t; cb(null,t);
    });
  }

  // ---- Rendering ----
  
  // *** ZAKTUALIZOWANA FUNKCJA RENDER TOP (z nagłówkiem pilota i 3 kolumnami) ***
  function renderTop(id){
    var box=document.getElementById('topinfo'); if(!box) return;

    // 1. Znajdź pilota w globalnym stanie
    var pilot = null;
    for(var i=0; i<state.rows.length; i++){
      if(state.rows[i].pilot && state.rows[i].pilot.id === id){
        pilot = state.rows[i].pilot;
        break;
      }
    }

    // 2. Zbuduj HTML nagłówka (z logo) - ZMIANA: Nagłówek 'h4' jest teraz renderowany tylko W środku topinfo (nie w summary)
    var headerHtml = '';
    if(pilot) {
      var corpLogo = pilot.corp_id ? logo('corp', pilot.corp_id, 128) : '';
      var alliLogo = pilot.alliance_id ? logo('alli', pilot.alliance_id, 128) : '';
      
      headerHtml = '<h4>' + escapeHtml(pilot.name || '') + '</h4>' +
                   '<div style="margin-bottom: 12px; font-size: 13px; line-height: 1.6;">' +
                     (pilot.corp_name ? ('<div style="display:flex; align-items:center;">' + corpLogo + escapeHtml(pilot.corp_name) + '</div>') : '') +
                     (pilot.alliance_name ? ('<div style="display:flex; align-items:center;">' + alliLogo + escapeHtml(pilot.alliance_name) + '</div>') : '') +
                   '</div>';
    } else {
      headerHtml = '<h4>Pilot ' + id + '</h4>'; // Fallback
    }

    // 3. Zbuduj HTML tabel (Ships | Systems | Alliances)
    var dat=topCache[id]||{ships:[],systems:[],alliances:[]};
    var ships=dat.ships||[], systems=dat.systems||[], alliances=dat.alliances||[];
    
    var tableHtml = '';
    if(!ships.length && !systems.length && !alliances.length){ 
      tableHtml = '<div class="muted">Brak danych (zKB TopAllTime).</div>'; 
    } else {
      var rows=Math.max(ships.length, systems.length, alliances.length);
      // ZMIANA: Nagłówki tabeli przeniesione do index.php, tutaj renderujemy tylko szczegóły
      tableHtml ='<table id="toptab"><thead><tr><th>Ships</th><th>Systems</th><th>Alliances</th></tr></thead><tbody>';
      for(var i=0;i<rows;i++){
        var sh=ships[i], sy=systems[i], al=alliances[i];
        
        var shTxt= sh? (escapeHtml(sh.name||'') + (sh.class? ' <span style="opacity:.7">('+escapeHtml(sh.class)+')</span>':'' ) + ' <span class="cnt">×'+(sh.kills||0)+'</span>') : '';
        var syTxt= sy? (escapeHtml(sy.name||'') + ' <span class="cnt">×'+(sy.kills||0)+'</span>') : '';
        var alTxt= al? (escapeHtml(al.name||'') + ' <span class="cnt">×'+(al.kills||0)+'</span>') : '';
        
        tableHtml+='<tr><td>'+ (shTxt||'') +'</td><td>'+ (syTxt||'') +'</td><td>'+ (alTxt||'') +'</td></tr>';
      }
      tableHtml+='</tbody></table>';
    }

    // 4. Połącz i renderuj
    box.innerHTML = headerHtml + tableHtml;
  }
  // *** KONIEC ZAKTUALIZOWANEJ FUNKCJI ***


  function renderLeft(){
    var tb=document.querySelector('#tab tbody'); if(!tb) return;
    tb.innerHTML='';
    var rows=state.rows.slice(0);
    
    // --- NOWA LOGIKA SORTOWANIA ---
    var sortKey = state.sortKey || 'alliance';
    var sortDir = state.sortDir || 'asc';
    var dir = (sortDir === 'asc' ? 1 : -1);

    function lowKey(s){ return (s||'').toString().toLowerCase(); }

    // Funkcja pomocnicza do pobierania wartości do sortowania
    function getSortValue(row, key) { // 'key' to parametr (string)
      var p = row.pilot || {};
      var s = row.stats || {};
      switch(key) {
        case 'pilot': return lowKey(p.name);
        case 'corp': return lowKey(p.corp_name || (p.corp_id ? ('Corporation ' + p.corp_id) : ''));
        case 'alliance': return lowKey(p.alliance_name || (p.alliance_id ? ('Alliance ' + p.alliance_id) : ''));
        case 'kills': return s.shipsDestroyed || s.kills || 0;
        case 'losses': return s.shipsLost || s.losses || 0;
        case 'kd':
          var k = s.shipsDestroyed || s.kills || 0;
          var l = s.shipsLost || s.losses || 0;
          return (l === 0) ? (k > 0 ? Infinity : 0) : (k / l);
        case 'solo':
          var k_s = s.shipsDestroyed || s.kills || 0;
          var solo_s = s.soloKills || s.solo || 0;
          return (k_s === 0) ? 0 : (100 * solo_s / k_s);
        case 'danger': return Math.round(s.dangerRatio || s.danger || 0);
        case 'tz': return analyzeTimezone(s || null); // <--- ZMIANA (przekazujemy cały obiekt 's' (stats))
        default: return lowKey(p.alliance_name); // Fallback
      }
    }

    rows.sort(function(a, b) {
      var valA = getSortValue(a, sortKey);
      var valB = getSortValue(b, sortKey);

      var cmp;
      if (typeof valA === 'number' && typeof valB === 'number') {
        cmp = valA - valB;
      } else {
        cmp = (valA || '').toString().localeCompare((valB || '').toString());
      }
      
      var result = cmp * dir;

      // Stabilne sortowanie dodatkowe (aby wyniki nie "skakały")
      if (result === 0) {
        if (sortKey !== 'alliance' && sortKey !== 'corp' && sortKey !== 'pilot') {
           var aAlli = getSortValue(a, 'alliance');
           var bAlli = getSortValue(b, 'alliance');
           var alliCmp = (aAlli || '').toString().localeCompare((bAlli || '').toString());
           if (alliCmp !== 0) return alliCmp;
        }
        if (sortKey !== 'corp' && sortKey !== 'pilot') {
           var aCorp = getSortValue(a, 'corp');
           var bCorp = getSortValue(b, 'corp');
           var corpCmp = (aCorp || '').toString().localeCompare((bCorp || '').toString());
           if (corpCmp !== 0) return corpCmp;
        }
        var aName = getSortValue(a, 'pilot');
        var bName = getSortValue(b, 'pilot');
        return (aName || '').toString().localeCompare((bName || '').toString());
      }
      
      return result;
    });
    // --- KONIEC NOWEJ LOGIKI SORTOWANIA ---

    // Aktualizuj klasy CSS w nagłówkach
    try {
      var headers = document.querySelectorAll('#tab th[data-sort]');
      headers.forEach(function(th) {
        th.classList.remove('sort-asc', 'sort-desc');
        if (th.getAttribute('data-sort') === sortKey) {
          th.classList.add(sortDir === 'asc' ? 'sort-asc' : 'sort-desc');
        }
      });
    } catch(e) { /* błąd w starych przeglądarkach */ }


    for(var i=0;i<rows.length;i++){
      var r=rows[i], p=r.pilot||{}, s=r.stats||{};
      // *** POPRAWKA: Używamy kluczy ZKillboard (np. shipsDestroyed) ***
      var kills = s.shipsDestroyed || s.kills || 0;
      var losses = s.shipsLost || s.losses || 0;
      var solo = s.soloKills || s.solo || 0;
      var danger = s.dangerRatio || s.danger || 0;
      
      var kd=(losses||0)? (kills/losses).toFixed(2):(kills?'\u221E':'0');
      var soloPct=(kills||0)? Math.round(100*(solo||0)/kills):0;
      var tzLabel = analyzeTimezone(s || null); // <--- ZMIANA (przekazujemy cały obiekt 's' (stats))
      var corpCell=p.corp_id?(logo('corp',p.corp_id,128)+escapeHtml(p.corp_name||'')):'-';
      var alliCell=p.alliance_id?(logo('alli',p.alliance_id,128)+escapeHtml(p.alliance_name||'')):'-';
      var tr=document.createElement('tr');
      
      tr.innerHTML='<td>'+escapeHtml(p.name||'')+'</td><td>'+corpCell+'</td><td>'+alliCell+'</td><td>'+kills+'</td><td>'+losses+'</td><td>'+kd+'</td><td>'+soloPct+'%</td><td>'+Math.round(danger)+'%</td><td>'+tzLabel+'</td>';
      (function(pid){
        tr.addEventListener('mouseenter', function(){
          var box=document.getElementById('topinfo'); if(box) box.innerHTML='<div class="muted">Loading…</div>';
          ensureTopFor(pid,function(){ renderTop(pid); });
        });
      })(p.id);
      tb.appendChild(tr);
    }
  }

  // Recompute matrix from killMem.byKill (shared killmail IDs => red)
  function rebuildAggFromKillMem(){
    if(!graph || !Array.isArray(graph.nodes)) return;
    var ids = graph.nodes.slice(0);
    if(!graph.aggr) graph.aggr = [];
    for (var i=0;i<ids.length;i++){
      if(!graph.aggr[i]) graph.aggr[i] = [];
      for (var j=0;j<ids.length;j++) graph.aggr[i][j] = 0;
    }
    var ownersMap = (killMem && killMem.byKill) ? killMem.byKill : {};
    for (var k in ownersMap){
      if(!ownersMap.hasOwnProperty(k)) continue;
      var arr = ownersMap[k];
      if(!arr || arr.length<2) continue;
      var seen = {}, uniq = [];
      for (var a=0;a<arr.length;a++){ var v=String(arr[a]); if(!seen[v]){ seen[v]=1; uniq.push(arr[a]); } }
      for (var x=0;x<uniq.length;x++){
        for (var y=x+1;y<uniq.length;y++){
          bumpPair(uniq[x], uniq[y], 1);
        }
      }
    }
    renderHeat();
  }

  function renderHeat(){
    var heat=document.getElementById('heat'); if(!heat) return;
    heat.innerHTML='';
    if(!graph||!graph.nodes){ heat.innerHTML='<div class="muted">Brak danych macierzy.</div>'; return; }
    var ids=graph.nodes; if(!ids.length){ heat.innerHTML='<div class="muted">At least 2 pilots are required to show the matrix.</div>'; return; }
    var coop=graph.matrix||[], aggr=graph.aggr||[], rawMeta=graph.meta||{};
    var meta={
      corp: rawMeta.corp||{},
      alli: rawMeta.alli||{},
      name: rawMeta.name||{},
      corp_hist: rawMeta.corp_hist||{},
      corp_hist_counts: rawMeta.corp_hist_counts||{},
      alli_counts: rawMeta.alli_counts||{}}; // POPRAWKA BŁĘDU SKŁADNI: Poprawne zamykanie obiektu meta
    
    var i,j,k;
    var corpCount={}, alliCount={};
    for(i=0;i<ids.length;i++){
      var id=ids[i]; var c=meta.corp[id]||0, a=meta.alli[id]||0;
      if(c) corpCount[c]=(corpCount[c]||0)+1;
      if(a) alliCount[a]=(alliCount[a]||0)+1;
    }
    var maxAgg=0;
    for(i=0;i<ids.length;i++){
      for(j=0;j<ids.length;j++){
        var v=((aggr[i]&&aggr[i][j])||0)+((aggr[j]&&aggr[j][i])||0);
        if(v>maxAgg) maxAgg=v;
      }
    }
    if(!maxAgg) maxAgg=1;
    var corpSets={};
    for(i=0;i<ids.length;i++){
      var arr=meta.corp_hist[ids[i]]||[];
      var s={}; for(k=0;k<arr.length;k++){ s[arr[k]]=1; }
      corpSets[ids[i]]=s;
    }
    var maxCorp=0; for(k in meta.corp_hist_counts){ if(meta.corp_hist_counts.hasOwnProperty(k) && meta.corp_hist_counts[k]>maxCorp) maxCorp=meta.corp_hist_counts[k]; }
    if(!maxCorp) maxCorp=1;
    var maxAlli=0; for(k in meta.alli_counts){ if(meta.alli_counts.hasOwnProperty(k) && meta.alli_counts[k]>maxAlli) maxAlli=meta.alli_counts[k]; }
    if(!maxAlli) maxAlli=1;

    var tbl=document.createElement('table'); tbl.className='heat-table';
    var thead=document.createElement('thead'); var thr=document.createElement('tr'); thead.appendChild(thr);
    var th0=document.createElement('th'); th0.appendChild(document.createTextNode('Pilot')); thr.appendChild(th0);
    for(i=0;i<ids.length;i++){
      var th=document.createElement('th'); th.className='sticky-top';
      var nm=meta.name[ids[i]]||String(ids[i]);
      th.innerHTML='<span class="colname">'+escapeHtml(nm)+'</span>';
      thr.appendChild(th);
    }
    tbl.appendChild(thead);

    var tb=document.createElement('tbody');
    for(i=0;i<ids.length;i++){
      var tr=document.createElement('tr');
      var td0=document.createElement('td'); td0.className='sticky-col'; td0.textContent=meta.name[ids[i]]||String(ids[i]); tr.appendChild(td0);
      for(j=0;j<ids.length;j++){
        var td=document.createElement('td');
        if(i===j){ td.appendChild(document.createTextNode('—')); }
        else{
          // czerwone: wspólny killmail (agresja) — suma obu kierunków
          var shots = (((aggr[i]&&aggr[i][j])||0) + ((aggr[j]&&aggr[j][i])||0));
          if(shots>0){
            var sR=shots/maxAgg; if(sR>1) sR=1;
            var light=90-Math.round(50*sR);
            td.style.background='hsl(0,75%,'+light+'%)';
            td.title='shots (A→B + B→A): '+shots.toFixed(2);
          } else {
            // zielone: shared corp/alliance (historyczne + fallback bieżącej)
            var A=ids[i], B=ids[j];
            var ai=meta.alli[A]||0, aj=meta.alli[B]||0;
            var sameAlli = ai && aj && (ai===aj);
            var setA=corpSets[A]||{}, setB=corpSets[B]||{};
            var shared=[], cid;
            for(cid in setA){ if(setA.hasOwnProperty(cid) && setB[cid]) shared.push(parseInt(cid,10)); }
            var corpStrength=0;
            if(shared.length && maxCorp>1){
              var best=0; for(var u=0;u<shared.length;u++){ var cnt=meta.corp_hist_counts[shared[u]]||1; if(cnt>best) best=cnt; }
              corpStrength=(best-1)/(maxCorp-1);
            }
            var alliStrength=0;
            if(sameAlli && maxAlli>1){
              var acnt=meta.alli_counts[ai]||1;
              alliStrength=(acnt-1)/(maxAlli-1);
            }
            var score=(corpStrength>alliStrength?corpStrength:alliStrength);
            // Fallback: jeśli brak historii, ale obecnie ta sama corp/alli — zazieleniamy
            if(score<=0){
              var sameCorp = (meta.corp[A] && meta.corp[A] === meta.corp[B]);
              if(sameCorp || sameAlli) score = 0.6;
            }
            if(score>0){
              var light2=90-Math.round(50*score);
              td.style.background='hsl(120,70%,'+light2+'%)';
              var tip=[];
              if(shared.length){
                shared.sort(function(a,b){ return (meta.corp_hist_counts[b]||0)-(meta.corp_hist_counts[a]||0); });
                tip.push('shared corp (365d) ×'+(meta.corp_hist_counts[shared[0]]||1));
              }
              if(sameAlli) tip.push('shared alliance ×'+(meta.alli_counts[ai]||1));
              if(score===0.6 && !shared.length){
                if(meta.corp[A] && meta.corp[A]===meta.corp[B]) tip.push('same current corp');
                if(sameAlli) tip.push('same current alliance');
              }
              td.title=tip.join(' | ');
            }
          }
        }
        tr.appendChild(td);
      }
      tb.appendChild(tr);
    }
    tbl.appendChild(tb);
    heat.appendChild(tbl);
  }

  function buildLocalGraphFromState(){
    var ids=[];
    var meta={corp:{},alli:{},name:{}, corp_hist:{}, corp_hist_counts:{}, alli_counts:{}};
    for(var i=0;i<state.rows.length;i++){
      var p=state.rows[i].pilot; if(!p||!p.id) continue;
      ids.push(p.id);
      meta.name[p.id]=p.name||String(p.id);
      meta.corp[p.id]=p.corp_id||0;
      meta.alli[p.id]=p.alliance_id||0;
      var cid=p.corp_id||0; if(cid){ meta.corp_hist[p.id]=[cid]; meta.corp_hist_counts[cid]=(meta.corp_hist_counts[cid]||0)+1; }
      var aid=p.alliance_id||0; if(aid){ meta.alli_counts[aid]=(meta.alli_counts[aid]||0)+1; }
    }
    return {nodes:ids, matrix:[], aggr:[], meta:meta};
  }

  // Uzupełnij meta lokalnymi danymi (gdy backend zwróci okrojone meta)
  function mergeGraphMetaWithState(){
    if(!graph) return;
    if(!graph.meta) graph.meta={};
    var m=graph.meta;
    if(!m.corp) m.corp={};
    if(!m.alli) m.alli={};
    if(!m.name) m.name={};
    if(!m.corp_hist) m.corp_hist={};
    if(!m.corp_hist_counts) m.corp_hist_counts={};
    if(!m.alli_counts) m.alli_counts={};
    for(var i=0;i<state.rows.length;i++){
      var p=(state.rows[i]&&state.rows[i].pilot)||{};
      if(!p.id) continue;
      m.name[p.id]=p.name||String(p.id);
      m.corp[p.id]=p.corp_id||0;
      m.alli[p.id]=p.alliance_id||0;
      if(p.corp_id){
        if(!m.corp_hist[p.id]) m.corp_hist[p.id]=[];
        if(m.corp_hist[p.id].indexOf(p.corp_id)<0) m.corp_hist[p.id].push(p.corp_id);
        m.corp_hist_counts[p.corp_id]=(m.corp_hist_counts[p.corp_id]||0)+1;
      }
      if(p.alliance_id){
        m.alli_counts[p.alliance_id]=(m.alli_counts[p.alliance_id]||0)+1;
      }
    }
  }

  // =====================
  //  INTERACTION MATRIX from zKillboard (shared kill = red)
  // =====================
  var killMem = { byPilot: {}, byKill: {} };

  function zkbSalt(){ return String(Math.floor(10000000 + Math.random() * 90000000)); }
  function zkbUrlForChar(charId){
    return 'https://zkillboard.com/cache/24hour/killlist/?s='+zkbSalt()+'&u=/character/'+encodeURIComponent(charId)+'/';
  }

  // losses for a character (same cache endpoint)
  function zkbUrlForCharLosses(charId){
    return 'https://zkillboard.com/cache/24hour/killlist/?s=' + zkbSalt() + '&u=/character/' + encodeURIComponent(charId) + '/losses/';
  }

  function ensureAggr(){
    if(!graph) return;
    var n=(graph.nodes&&graph.nodes.length)||0;
    if(!graph.aggr) graph.aggr=[];
    for(var i=0;i<n;i++){
      if(!graph.aggr[i]) graph.aggr[i]=[];
      for(var j=0;j<n;j++){
        if(typeof graph.aggr[i][j] !== 'number') graph.aggr[i][j]=0;
      }
    }
  }

  function idxOf(id){ if(!graph||!graph.nodes) return -1; for(var i=0;i<graph.nodes.length;i++) if(graph.nodes[i]===id) return i; return -1; }
  function bumpPair(aId,bId,amount){
    var ai=idxOf(aId), bi=idxOf(bId);
    if(ai<0 || bi<0 || ai===bi) return;
    ensureAggr();
    var v=(typeof amount==='number'?amount:1);
    graph.aggr[ai][bi]=(graph.aggr[ai][bi]||0)+v;
    graph.aggr[bi][ai]=(graph.aggr[bi][ai]||0)+v;
  }

  function processKillIdsForPilot(charId, killIds){
    if(!killIds||!killIds.length) return;
    var seen=killMem.byPilot[charId]||{};
    for(var i=0;i<killIds.length;i++){
      var k=String(killIds[i]);
      if(seen[k]) continue;
      seen[k]=1;
      var owners=killMem.byKill[k]||[];
      for(var p=0;p<owners.length;p++){ bumpPair(charId, owners[p], 1); } // wspólny kill -> czerwono
      owners.push(charId);
      killMem.byKill[k]=owners;
    }
    killMem.byPilot[charId]=seen;
    renderHeat();
  }

  // Parser obsługujący tablice, obiekty i mapy {"12345": {...}}
  function parseKillIdsFromZkb(json){
    var out=[];
    function pushId(v){ var n=Number(v); if(isFinite(n)&&n>0) out.push(n); }
    function walk(node){
      if(!node) return;
      if(Array.isArray(node)){ for(var i=0;i<node.length;i++) walk(node[i]); return; }
      if(typeof node==='number' || typeof node==='string'){ pushId(node); return; }
      if(typeof node==='object'){
        if('killmail_id' in node) pushId(node.killmail_id);
        if('killID' in node) pushId(node.killID);
        var keys=Object.keys(node);
        if(keys.length && keys.every(function(k){ return /^\d+$/.test(k); })){
          for(var k=0;k<keys.length;k++) pushId(keys[k]);
        }
        for(var j=0;j<keys.length;j++){ try{ walk(node[keys[j]]); }catch(_e){} }
      }
    }
    walk(json);
    var seen={}, ded=[];
    for(var t=0;t<out.length;t++){ var v=String(out[t]); if(!seen[v]){ seen[v]=1; ded.push(out[t]); } }
    return ded;
  }

  // Pobieranie cache zKB przez backend (omija CORS/302)
  function loadZkbFromUrl(url, charId, cb){
    api('zkbByUrl', url, function(err, json){
      var killIds = (!err && json) ? parseKillIdsFromZkb(json) : [];
      if(killIds && killIds.length){ processKillIdsForPilot(charId, killIds); debug('zKB ['+charId+']: '+killIds.length+' kill(s)'); }
      else { debug('zKB ['+charId+']: 0 kills'); }
      if(cb) cb();
    });
  }
  function loadZkbForPilot(charId, cb){
    var url = zkbUrlForChar(charId);
    loadZkbFromUrl(url, charId, cb);
  }
  function loadZkbForAll(ids, done){
    var i=0;
    function step(){
      if(i>=ids.length){ if(done) done(); return; }
      var id = ids[i++];
      // KILLS (default)
      var urlK = zkbUrlForChar(id);
      // LOSSES (extra)
      var urlL = (typeof zkbUrlForCharLosses==='function') ? zkbUrlForCharLosses(id) : null;
      loadZkbFromUrl(urlK, id, function(){
        if(urlL){
          loadZkbFromUrl(urlL, id, function(){ setTimeout(step, 80); });
        } else {
          setTimeout(step, 80);
        }
      });
    }
    step();
  }

  // ---- onAnalyze (UX bez zmian) ----
  window.__run = function onAnalyze(){
    if(busy) return; busy=true;
    var btn=document.getElementById('go'); if(btn) btn.disabled=true;
    setStatus('Parsing input…');
    var raw=(memo&&memo.value?memo.value:'').split(/\n+/);
    
    // *** POPRAWKA OBSŁUGI TABULATORA ***
    var names=[];
    for(var i=0;i<raw.length;i++){
      var line = (raw[i]||'');
      var s = line.split('\t')[0]; // Bierzemy tylko część przed pierwszym tabulatorem
      s = s.replace(/^\s+|\s+$/g,''); // Czyścimy (trim)
      if(s) names.push(s);
    }
    // *** KONIEC POPRAWKI ***
    
    names=dedupe(names);
    if(!names.length){ setStatus('No input data'); if(btn) btn.disabled=false; busy=false; return; }

    api('resolveBatch',{names:names}, function(err,res){
      var map=(res&&res.map)?res.map:{};

      function afterMap(){
        state.rows=[]; var ids=[];
        setStatus('Loading character data…');
        var idx=0;
        function nextPil(){
          if(idx>=names.length){
            if(state.rows.length===0){ setStatus('Failed to load any pilot.'); if(btn) btn.disabled=false; busy=false; return; }
            setStatus('Statystyki z zKB…');
            var si=0;
            function nextStats(){
              if(si>=ids.length){
                setStatus('Building matrix…');
                api('graph',{ids:ids}, function(e2,g){
                  if(e2 || !g || !g.nodes || !g.nodes.length){
                    debug('graph fallback: '+(e2? (e2.message||e2) : 'empty'));
                    graph = buildLocalGraphFromState();
                    mergeGraphMetaWithState();
                    ensureAggr();
                    renderHeat();
                    loadZkbForAll(ids, function(){ rebuildAggFromKillMem(); });
                    if(btn) btn.disabled=false; busy=false; return;
                  }
                  graph=g;
                  mergeGraphMetaWithState();
                  ensureAggr();
                  renderHeat();
                  // ZMIANA: Zwijamy panel tylko jeśli jest zamknięty
                  if(ids[0]) ensureTopFor(ids[0], function(){ renderTop(ids[0]); });
                  
                  loadZkbForAll(ids, function(){ rebuildAggFromKillMem(); });
                  if(btn) btn.disabled=false; busy=false;
                });
                return;
              }
              var id2=ids[si++];
              api('stats',{id:id2}, function(e3,r3){
                if(!e3 && r3 && r3.stats){
                  
                  // DODANA LINIA DIAGNOSTYKA
                  if(si === 1) { debug(JSON.stringify(r3.stats)); } // Pokaż dane stats pierwszego pilota
                  
                  for(var a=0;a<state.rows.length;a++){
                    if(state.rows[a].pilot && state.rows[a].pilot.id===id2){ 
                      // state.rows[a].stats = r3.stats; // Stara linia
                      // Nowa linia: Łączymy stats (teraz r3.stats to cały obiekt z zkb)
                      state.rows[a].stats = Object.assign(state.rows[a].stats || {}, r3.stats);
                      break; 
                    }
                  }
                  renderLeft();
                }
                setTimeout(nextStats, 25);
              });
            }
            nextStats(); return;
          }

          var n=names[idx++]; var id=map[n.toLowerCase()];
          function gotPilot(pi){
            if(pi){ state.rows.push({pilot:pi, stats:{kills:0,losses:0,solo:0,group:0,danger:0}}); ids.push(pi.id); renderLeft(); }
            setTimeout(nextPil, 25);
          }

          if(!id){
            resolveNamesClient([n], function(_e,m2){
              var id2=m2[n.toLowerCase()];
              if(!id2){ gotPilot(null); }
              else { loadPilotClient(id2, function(e5,pi){ gotPilot(e5?null:pi); }); }
            });
          } else {
            api('pilot',{id:id}, function(e4,r4){
              var pi=(r4&&r4.pilot)?r4.pilot:null;
              if(!pi){ loadPilotClient(id, function(e5,pi2){ gotPilot(e5?null:pi2); }); }
              else { gotPilot(pi); }
            });
          }
        }
        nextPil();
      }

      if(!map || !Object.keys(map).length){
        resolveNamesClient(names, function(e1,m){ map=m||{}; afterMap(); });
      } else { afterMap(); }
    });
  }
  
  // ---- NOWA FUNKCJA DO OBSŁUGI SORTOWANIA ----
  function bindSortHandlers() {
    var headers = document.querySelectorAll('#tab th[data-sort]');
    if (!headers.forEach) return; // Ochrona dla starych przeglądarek

    headers.forEach(function(th) {
      th.onclick = function() {
        var newKey = th.getAttribute('data-sort');
        if (!newKey) return;

        if (state.sortKey === newKey) {
          // Odwróć kierunek
          state.sortDir = (state.sortDir === 'asc' ? 'desc' : 'asc');
        } else {
          // Nowa kolumna
          state.sortKey = newKey;
          // Domyślnie sortuj liczby malejąco (np. Kills), a tekst rosnąco
          if (['kills', 'losses', 'kd', 'solo', 'danger'].indexOf(newKey) !== -1) {
            state.sortDir = 'desc';
          } else {
            state.sortDir = 'asc';
          }
        }
        renderLeft(); // Przerenderuj tabelę z nowym sortowaniem
      };
    });
  }
  // ---- KONIEC NOWEJ FUNKCJI ----
  
  // Funkcja uruchamiająca po załadowaniu JS
  function init(){
      // Upewniamy się, że panel jest domyślnie rozwinięty i ma poprawną ikonę
      if (topPanelWrap) {
          topPanelWrap.classList.remove('collapsed');
      }
      // ZMIANA: Inicjalna ikona to trójkąt w lewo (sygnalizuje zwijanie)
      if (collapseBtn) {
          collapseBtn.textContent = '◀'; 
      }
      
      bindSortHandlers();
  }


  // Bind UI
  // ZMIANA: Wiązania przeniesione do IIFE, aby były dostępne zaraz po wykonaniu skryptu.
  var go=document.getElementById('go'); 
  if(go) go.onclick=function(){ if(window.__run) window.__run(); };
  
  var diag=document.getElementById('diag'); 
  if(diag) diag.onclick=function(){ var pre=document.getElementById('dbg'); if(pre) pre.textContent='Running diagnostics…'; api('diag',{}, function(e,r){ var j=r&&r.diag?r.diag:r; if(pre) pre.textContent=JSON.stringify(j||r||{}, null, 2); }); };
  
  var clr=document.getElementById('clr'); 
  if(clr) clr.onclick=function(){ if(memo) memo.value=''; state.rows=[]; graph=null; killMem={byPilot:{},byKill:{}}; var el; if((el=document.querySelector('#tab tbody'))) el.innerHTML=''; if((el=document.getElementById('heat'))) el.innerHTML=''; if((el=document.getElementById('topinfo'))) el.innerHTML=''; };

  // ---- Inicjalizacja ----
  init();

})(); // IIFE end


// --- Global Ctrl+V: wklej do #memo i uruchom analizę ---
document.addEventListener('paste', function (event) {
  try {
    var memo = document.getElementById('memo');
    if (!memo) return;
    var cd = event.clipboardData || window.clipboardData;
    var text = cd ? cd.getData('text') : '';
    if (!text) return;
    event.preventDefault();
    memo.value = '';
    memo.value = text;
    var btn = document.getElementById('go') || document.getElementById('analyze');
    if (btn && typeof btn.click === 'function') btn.click();
    else if (typeof window.__run === 'function') window.__run();
  } catch(_) { /* ignore */ }
}, true);
